<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jenkins笔记]]></title>
    <url>%2F2017%2F06%2F11%2Fjenkins%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[启动Jenkins1java -jar jenkins.war --httpPort=8001 遇到的问题 查看jenkins的HTML文件，然后样式，或者引用的字体加载不出来 Refused to load the font ‘http://localhost:8080/job/nec-server-test/extent-report/extentreports/css/fonts/Roboto-Thin.woff‘ because it violates the following Content Security Policy directive: “default-src ‘none’”. Note that ‘font-src’ was not explicitly set, so ‘default-src’ is used as a fallback. 出现这种问题的情况是jenkins默认使用严格的加载模式，不允许外部的一些js操作导致的，需要将一些规则放宽参考：https://wiki.jenkins-ci.org/display/JENKINS/Configuring+Content+Security+Policy 解决办法：在启动jenkins的时候 使用java -Dhudson.model.DirectoryBrowserSupport.CSP= -jar jenkins.war代替java -jar jenkins.war]]></content>
  </entry>
  <entry>
    <title><![CDATA[git常见操作及设置]]></title>
    <url>%2F2017%2F06%2F11%2Fgit%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E5%8F%8A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[push设置无需每次输入密码http连接方式 方法一 1git config --global credential.helper wincred 方法二 1234567891011http://[username]:[password]@zychen.com.cn/scm/nec/nec-server.git``` &gt;username: 远程代码块的登录账号password：远程代码块的登录密码@后面的内容及为远程代码块#### ssh连接方式[传送门](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#platform-mac)### 基本配置 配置用户信息git config –global user.name stash &lt;用户名&gt;git config –global user.email &lt;公司邮箱&gt; 关闭自动crlf转换，开启crlf检查git config –global core.autocrlf falsegit config –global core.safecrlf true 给命令设置别名git config –global alias.st status123### 常用操作* 删除远程仓库的分支 git push origin :远程分支名1* 修剪远程中已经删除的分支，但在本地还存在的 git remote prune origin1* 回退本地commit的历史 git reset HEAD^^1* 将别的分支的commit的历史复制到当前分支 git cherry pick -提交的commit号```]]></content>
  </entry>
  <entry>
    <title><![CDATA[jacoco统计远程服务器代码覆盖率]]></title>
    <url>%2F2017%2F06%2F09%2Fjacoco%E7%BB%9F%E8%AE%A1%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%2F</url>
    <content type="text"><![CDATA[场景需求由于项目的需要，当前我们开发的服务端代码和接口以及集成测试代码不是写在同一个项目下，当测接口时，我们发送一个http request请求到Linux服务端，然后服务端返回一个response，这样的情况如何做代码覆盖率统计？ 前提条件 安装ant，并且设置环境变量 下载jacoco的jar包 点击下载 服务端设置（Linux）现在的springboot应用非常多，其本身自带tomcat，网上很多都是说修改tomcat的Catalina.sh文件来使用javaagent：1JAVA_OPTS="-javaagent:[yourPath/]jacocoagent.jar=includes=com.didispace.*,output=tcpserver,port=8044,address=30.11.227.26 -Xverify:none" 针对springboot应用使用如下方式运行：1java -javaagent:D:/tools/jacoco-0.7.9/lib/jacocoagent.jar=includes=com.didispace.*,output=tcpserver,port=8044,address=30.11.227.26 -jar Chapter1-1.0.0.jar output有4个值，分别是file,tcpserver,tcpclient,mbean，默认是file。使用file的方式只有在停掉应用服务的时候才能产生覆盖率文件，而使用tcpserver的方式可以在不停止应用服务的情况下下载覆盖率文件 客户端设置（Windows）在客户端运行ant dump之前，这时可以对服务端进行接口以及功能测试，这时所有的调服务端接口操作都会记录代码覆盖率。 结合Jenkins生成report在目录D:\test-resourse\下新建一个文件夹trap，trap文件夹下新建一个build.xml文件，文件内容如下：123456789101112131415&lt;?xml version="1.0" ?&gt;&lt;project name="Jacoco" xmlns:jacoco="antlib:org.jacoco.ant" default="jacoco"&gt; //此处的value里面的路径，对应上面下载的jar文件路径 &lt;property name="jacocoantPath" value="D:/tools/jacoco-0.7.9/lib/jacocoant.jar"/&gt; &lt;property name="integrationJacocoexecPath" value="./jacoco-integration.exec"/&gt; &lt;taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml"&gt; &lt;classpath path="$&#123;jacocoantPath&#125;" /&gt; &lt;/taskdef&gt; &lt;target name="dump"&gt;//此处的address地址即为程序/tomcat所在的linux机器地址，host与上文命令行host对应 &lt;jacoco:dump address="30.11.227.26" port="8044" reset="true" destfile="$&#123;integrationJacocoexecPath&#125;" append="false"/&gt; &lt;/target&gt;&lt;/project&gt; 接着在build.xml文件目录下运行ant dump命令就会在当前目录下出现一个.exec后缀名结尾的文件，出现如下图所示的代表运行成功 本地生成report在trap文件夹下新建一个localReport文件夹，localReport文件夹下新建一个build.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" ?&gt;&lt;project name="jacoco" xmlns:jacoco="antlib:org.jacoco.ant" default="jacoco"&gt; &lt;!--Jacoco的安装路径--&gt; &lt;property name="jacocoantPath" value="[yourPath/]jacocoant.jar"/&gt; &lt;!--最终生成.exec文件的路径，Jacoco就是根据这个文件生成最终的报告的--&gt; &lt;property name="jacocoexecPath" value="[yourPath/]jacoco.exec"/&gt; &lt;!--生成覆盖率报告的路径--&gt; &lt;property name="reportfolderPath" value="[storageReportPath]"/&gt; &lt;!--远程Tomcat服务的ip地址--&gt; &lt;property name="server_ip" value="100.44.44.144"/&gt; &lt;!--前面配置的远程Tomcat服务打开的端口，要跟上面配置的一样--&gt; &lt;property name="server_port" value="8044"/&gt; &lt;!--本地源代码路径--&gt; &lt;property name="checkOrderSrcpath" value="[Srcpath]" /&gt; &lt;!--本地.class文件路径--&gt; &lt;property name="checkOrderClasspath" value="[classPath]" /&gt; &lt;!--让ant知道去哪儿找Jacoco--&gt; &lt;taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml"&gt; &lt;classpath path="$&#123;jacocoantPath&#125;" /&gt; &lt;/taskdef&gt; &lt;!--dump任务: 根据前面配置的ip地址，和端口号， 访问目标Tomcat服务，并生成.exec文件。--&gt; &lt;target name="dump"&gt; &lt;jacoco:dump address="$&#123;server_ip&#125;" reset="false" destfile="$&#123;jacocoexecPath&#125;" port="$&#123;server_port&#125;" append="true"/&gt; &lt;/target&gt; &lt;!--jacoco任务: 根据前面配置的源代码路径和.class文件路径， 根据dump后，生成的.exec文件，生成最终的html覆盖率报告。--&gt; &lt;target name="report"&gt; &lt;delete dir="$&#123;reportfolderPath&#125;" /&gt; &lt;mkdir dir="$&#123;reportfolderPath&#125;" /&gt; &lt;jacoco:report&gt; &lt;executiondata&gt; &lt;file file="$&#123;jacocoexecPath&#125;" /&gt; &lt;/executiondata&gt; &lt;structure name="JaCoCo Report"&gt; &lt;group name="Check Order related"&gt; &lt;classfiles&gt; &lt;fileset dir="$&#123;checkOrderClasspath&#125;" /&gt; &lt;/classfiles&gt; &lt;sourcefiles encoding="gbk"&gt; &lt;fileset dir="$&#123;checkOrderSrcpath&#125;" /&gt; &lt;/sourcefiles&gt; &lt;/group&gt; &lt;/structure&gt; &lt;html destdir="$&#123;reportfolderPath&#125;" encoding="utf-8" /&gt; &lt;/jacoco:report&gt; &lt;/target&gt;&lt;/project&gt; 在刚才新建的build.xml目录下运行如下命令1234//先执行ant dump//再执行ant report 这时会在build.xml配置文件reportfolderPath属性配置的路径下生成几个文件，其中有一个index.html文件，将其打开就是覆盖率报告]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenide的入门教程]]></title>
    <url>%2F2017%2F06%2F08%2Fselenide%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Quick Start在pom.xml中加入如下依赖123456&lt;dependency&gt; &lt;groupId&gt;com.codeborne&lt;/groupId&gt; &lt;artifactId&gt;selenide&lt;/artifactId&gt; &lt;version&gt;4.4.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 常用配置 selenide默认使用Firefox浏览器，如何切换成chrome浏览器？ 12System.setProperty("webdriver.chrome.driver", driverPath);Configuration.browser="chrome"; selenide如何设置代理？ 123Proxy proxy = new Proxy();proxy.setHttpProxy("127.0.0.1:8080");WebDriverRunner.setProxy(proxy); selenide如何修改报告默认生成路径？ 1Configuration.reportsFolder = "target/reports/test"+Configuration.browser; selenide如何下载非&lt;a&gt;标签的文件？ 12//默认值是FileDownloadMode.HTTPGET，此值只用作用于&lt;a&gt;标签Configuration.fileDownload = FileDownloadMode.PROXY; 如何保持浏览器运行完不关闭？ 12//默认值是falseConfiguration.holdBrowserOpen = true; 如何使用自己实例化的driver？ 1WebDriverRunner.setWebDriver(driver); 此处需要注意，如果使用自己设置的driver，selenide不会自动关闭brower,需要我们手动关闭！ 常见操作 打开一个url： 1open("https://www.baidu.com/"); 鼠标点击： 123//默认使用css selector的方式来查找元素Selenide.$(element).click();Selenide.$(By.xpath(element)).click(); 文本框赋值：Selenide.$(By.xpath(element)).doubleClick(); 鼠标事件：Selenide.$(By.xpath(element)).contextClick(); 鼠标右键事件：Selenide.$(By.xpath(element)).setValue(value); 判断元素是否存在：Selenide.$(By.xpath(element)).exists(); 下载文件的操作：Selenide.$(By.xpath(element)).download(); 默认只能下载&lt;a&gt;标签的元素若想下载其他标签里面的元素则需另外设置 上传文件的操作：Selenide.$(By.xpath(element)).uploadFile(file); uploadFile的参数为File类型 查询元素的文本内容Selenide.$(By.xpath(element)).text(); 等待直到存在某个元素Selenide.$(By.xpath(element)).waitUntil(exist , timeoutSeconds*1000); 等待直到元素在页面可见Selenide.$(By.xpath(element)).waitUntil(visible , timeoutSeconds*1000); 等待直到满足两个条件中的任意一个,就相当于if(a || b){}这种写法，第一个参数是备注Selenide.$(By.xpath(element)).waitUntil(or(&quot;有一个相等&quot;, text(param1), text(param2)) , timeoutSeconds*1000); 等待直到某个元素不存在Selenide.$(By.xpath(element)).waitUntil(hidden, timeoutSeconds*1000); 等待直到匹配到文本内容Selenide.$(By.xpath(element)).waitUntil(matchesText(text),timeoutSeconds*1000) 此处matchesText里面可以匹配正则表达式 不存在某个元素Selenide.$(By.xpath(element)).shouldNot(exist); 移动鼠标到某个元素上Selenide.$(By.xpath(element)).hover() 获取当前页面titleSelenide.title() 获取当前页面urlWebDriverRunner.url() 切换到另一个页面Selenide.switchTo().window(nameOrHandle) 获取当前driverWebDriverRunner.getWebDriver(); 清除浏览器cookieSelenide.clearBrowserCookies(); 刷新当前页面Selenide.refresh(); 出现alert时候出来情况12Selenide.confirm();Selenide.dismiss();]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenide</tag>
        <tag>框架</tag>
      </tags>
  </entry>
</search>