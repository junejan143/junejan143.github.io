<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计一套具备LRU过期策略的缓存程序]]></title>
    <url>%2F2017%2F06%2F22%2F%E8%AE%BE%E8%AE%A1%E4%B8%80%E5%A5%97%E5%85%B7%E5%A4%87LRU%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E7%9A%84%E7%BC%93%E5%AD%98%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[考察点: 缓存容器的设计：LinkedHashMap的使用 缓存容器并发考虑 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.LinkedHashMap;import java.util.Map;/** * Created by zhangyuanchen on 2017/6/22. */public class LruTest&lt;K, V&gt; &#123; private int cacheSize; private LinkedHashMap&lt;K, V&gt; map; private static final float loadFactor = 0.75f; /** * @param cacheSize 缓存大小 */ public LruTest(int cacheSize) &#123; this.cacheSize = cacheSize; int initialCapacity = (int) Math.ceil(cacheSize / loadFactor) + 1; map = new LinkedHashMap&lt;K, V&gt;(initialCapacity, loadFactor, true) &#123; @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; LruTest.this.cacheSize; &#125; &#125;; &#125; public synchronized void put(K key, V value) &#123; map.put(key, value); &#125; public synchronized V get(K key) &#123; return map.get(key); &#125; public static void main(String[] args) &#123; LruTest&lt;Integer, String&gt; lruTest = new LruTest&lt;Integer, String&gt;(3); lruTest.put(1, "one"); // 1 lruTest.put(2, "two"); // 2,1 lruTest.put(3, "three"); // 3,2,1 lruTest.put(4, "four"); // 4,3,2 lruTest.get(3); // 3,4,2 lruTest.get(2); // 2,3,4 &#125;&#125; LinkedHashMap中initialCapacity初始容量，loadFactor扩容因子，true代表使用访问顺序，false代表使用插入顺序，一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序 重写LinkedHashMap中的removeEldestEntry方法，该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，即永远不能移除最旧的元素， 重写后会移出最旧的元素]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>集合类</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CountDownLatch、ExecutorService的使用]]></title>
    <url>%2F2017%2F06%2F11%2FCountDownLatch%E3%80%81ExecutorService%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314public class TestService &#123; public static void main(String[] args) &#123; CountDownLatch countDownLatch = new CountDownLatch(50); //开启一个线程池 ExecutorService executor = Executors.newCachedThreadPool(); //执行TestThread里面的run方法 executor.execute(new TestThread(countDownLatch)); executor.execute(new TestThread(countDownLatch)); executor.execute(new TestThread(countDownLatch)); //线程池不再接受新的任务 executor.shutdown(); &#125;&#125; executor.execute(new TestThread(countDownLatch));这段传入的是一个实现Runnable接口的类，执行的方法则是run方法里面的内容，每一个execute则是开启一个线程 12345678910111213public class TestThread implements Runnable&#123; private CountDownLatch countDownLatch; public TestThread( CountDownLatch countDownLatch )&#123; this.countDownLatch = countDownLatch; &#125; public void run() &#123; while (countDownLatch.getCount() &gt;0)&#123; countDownLatch.countDown(); System.out.println("输出："+Thread.currentThread()+"&gt;&gt;&gt;"+ countDownLatch.getCount()); &#125; &#125;&#125; CountDownLatch countDownLatch = new CountDownLatch(50);这段是启用一个线程辅助类，传入的参数是一个int类型的计数，在TestThread中的run方法中，每执行一次，通过调用countDownLatch.countDown();方法计数减一，当计数内容为0时，则子线程全部执行完成，此时主线程才能继续往下执行。 输出结果12345678910111213141516输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;49输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;47输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;46输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;45输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;44输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;43输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;42输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;41输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;40输出：Thread[pool-1-thread-2,5,main]&gt;&gt;&gt;48输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;39输出：Thread[pool-1-thread-2,5,main]&gt;&gt;&gt;38输出：Thread[pool-1-thread-3,5,main]&gt;&gt;&gt;36输出：Thread[pool-1-thread-1,5,main]&gt;&gt;&gt;36输出：Thread[pool-1-thread-3,5,main]&gt;&gt;&gt;34... 具体用法请google]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows，mac 更新npm包管理器]]></title>
    <url>%2F2017%2F06%2F11%2Fwindows%EF%BC%8Cmac-%E6%9B%B4%E6%96%B0npm%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在* nix（OSX，Linux等）上升级 您可能需要使用sudo前缀这些命令，尤其是在Linux或OS X上，如果您使用其默认安装程序安装了Node。 您可以使用以下方式升级到最新版本的npm：1npm install -g npm@latest 或升级到最新的LTS版本：1npm install -g npm@lts 在Windows上升级你可以你可以从这里下载或者跟着如下手册概述操作 默认情况下，npm和nodejs一起安装在C:\Program Files (x86)\nodejs。npm的默认安装包（包括潜在的npm本身）分别存储在用户特定的目录中，这是目录（C:\Users\&lt;username&gt;\AppData\Roaming\npm），因为安装程序在PATH中将C:\Program Files (x86)\nodejs放在C:\Users\&lt;username&gt;\AppData\Roaming\npm之前，它将始终使用安装了nodejs的npm版本，而不是你使用npm -g install npm@&lt;version&gt;安装的npm版本，要解决这个问题，您可以执行以下操作之一 选项1：编辑Windows环境变量的PATH路径，将％appdata％\ npm放在％ProgramFiles％\ nodejs之前。 请记住，当您对PATH进行更改或如何安装npm时，需要重新启动cmd.exe（并可能重新启动Windows）。 选项2：删除两者 %ProgramFiles%\nodejs\npm %ProgramFiles%\nodejs\npm.cmd 选项3：导航到％ProgramFiles％\ nodejs \ node_modules \ npm并将npmrcfile复制到另一个文件夹或桌面。然后打开cmd.exe并运行以下命令： 12cd %ProgramFiles%\nodejsnpm install npm@latest 如果在node.js安装程序中安装了npm，执行上述步骤之一后，执行以下操作。 选项1或2进入％ProgramFiles％\ nodejs \ node_modules \ npm，并在新的npm文件夹中复制名为npmrc的文件，该文件夹应为％appdata％\ npm \ node_modules \ npm。这将告诉新的npm全局安装的软件包。 选项3将npmrc文件复制回％ProgramFiles％\ nodejs \ node_modules \ npm （如果您运行的是Windows 7，并且没有％appdata％\ npm目录，请参阅下面的内容） 运行以下命令查看npm将安装全局包以验证其是否正确1npm config get prefix -g 如果未设置为&lt;X&gt;:\Users\&lt;user&gt;\AppData\Roaming\npm，则可以运行以下命令来更正它：1npm config set prefix "$&#123;APPDATA&#125;/npm" -g 顺便提一句，如果你希望这个软件包不被安装到你的漫游配置文件中（因为你的共享网络上有一个配额，或是使域名登录或者退出一个域名），你可以把它放在你本地的应用数据中：1npm config set prefix "$&#123;LOCALAPPDATA&#125;/npm" -g …以及将%APPDATA%\npm复制到%LOCALAPPDATA%\npm（当然更新您的％PATH％）。 尝试清除npm缓存1npm cache clean 原文链接：https://github.com/npm/npm/wiki/Troubleshooting#a-brief-note-on-the-built-in-windows-configuration]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[testng集成allure测试报告]]></title>
    <url>%2F2017%2F06%2F11%2Ftestng%E9%9B%86%E6%88%90allure%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[pom.xml文件里面的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;parent&gt; &lt;groupId&gt;ru.yandex.qatools.allure&lt;/groupId&gt; &lt;artifactId&gt;allure-examples-parent&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/parent&gt;&lt;properties&gt; &lt;selenide.version&gt;4.4.1&lt;/selenide.version&gt; &lt;testng&gt;fvt&lt;/testng&gt; &lt;aspectj.version&gt;1.8.9&lt;/aspectj.version&gt; &lt;allure.version&gt;1.5.2&lt;/allure.version&gt;&lt;/properties&gt;&lt;!-- testng--&gt;&lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;6.9.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- selenide--&gt;&lt;dependency&gt; &lt;groupId&gt;com.codeborne&lt;/groupId&gt; &lt;artifactId&gt;selenide&lt;/artifactId&gt; &lt;version&gt;$&#123;selenide.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Allure --&gt;&lt;dependency&gt; &lt;groupId&gt;ru.yandex.qatools.allure&lt;/groupId&gt; &lt;artifactId&gt;allure-testng-adaptor&lt;/artifactId&gt; &lt;version&gt;$&#123;allure.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- allure--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.18.1&lt;/version&gt; &lt;configuration&gt; &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt; &lt;suiteXmlFiles&gt; &lt;suiteXmlFile&gt;$&#123;testng&#125;.xml&lt;/suiteXmlFile&gt; &lt;/suiteXmlFiles&gt; &lt;argLine&gt; -javaagent:"$&#123;settings.localRepository&#125;/org/aspectj/aspectjweaver/$&#123;aspectj.version&#125;/aspectjweaver-$&#123;aspectj.version&#125;.jar" &lt;/argLine&gt; &lt;systemProperties&gt; &lt;property&gt; &lt;name&gt;allure.results.directory&lt;/name&gt; &lt;value&gt;$&#123;project.build.directory&#125;/allure-results&lt;/value&gt; &lt;/property&gt; &lt;/systemProperties&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;$&#123;aspectj.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;!--Needed only to show reports locally. Run jetty:run and open localhost:8080 to show the report--&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.10.v20150310&lt;/version&gt; &lt;configuration&gt; &lt;webAppSourceDirectory&gt;$&#123;project.build.directory&#125;/site/allure-maven-plugin&lt;/webAppSourceDirectory&gt; &lt;stopKey&gt;stop&lt;/stopKey&gt; &lt;stopPort&gt;1234&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;&lt;reporting&gt; &lt;excludeDefaults&gt;true&lt;/excludeDefaults&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;ru.yandex.qatools.allure&lt;/groupId&gt; &lt;artifactId&gt;allure-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/reporting&gt; 上传错误case的截图?实现一个监听器创建一个类AllureReporterListener实现IHookable接口1234567891011121314151617181920public class AllureReporterListener implements IHookable&#123; @Override public void run(IHookCallBack callBack, ITestResult testResult) &#123; callBack.runTestMethod(testResult); if (testResult.getThrowable() != null) &#123; try &#123; takeScreenShot(testResult.getMethod().getMethodName()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Attachment(value = "Failure in method &#123;0&#125;", type = "image/png") private byte[] takeScreenShot(String methodName) throws Exception&#123; File screenshot = Screenshots.getLastScreenshot(); return Files.toByteArray(screenshot); &#125;&#125; 如何使用该监听器？两种方法： 在testng.xml中加入一个listeners标签 12345678910&lt;suite name="TestAll" parallel="methods" skipfailedinvocationcounts="true" thread-count="1"&gt; &lt;listeners&gt; &lt;listener class-name="com.alibaba.selenide.utils.AllureReporterListener"/&gt; &lt;/listeners&gt; &lt;test name="AllTest"&gt; &lt;classes&gt; &lt;class name="com.alibaba.selenide.cases.IdeTest" /&gt; &lt;/classes&gt; &lt;/test&gt;&lt;/suite&gt; 在case中加入@Listeners注解 12345678910111213@Listenerspublic class IdeTest extends BaseTest&#123; @BeforeMethod public void setup() throws Exception &#123; preprocess(); &#125; @Title("创建节点，运行，提交，测试运行") @Test public void nodeTest() &#123; &#125; 如何运行？ 先运行： mvn clean test 运行case再运行： mvn site 生成站点最后运行： mvn jetty:run 查看报告 可能遇到的问题？ 生成的报告每个case出现两个一模一样的casehttps://github.com/allure-framework/allure1/issues/731去掉pom文件中maven-surefire-plugin中这个配置123456&lt;properties&gt; &lt;property&gt; &lt;name&gt;listener&lt;/name&gt; &lt;value&gt;ru.yandex.qatools.allure.testng.AllureTestListener&lt;/value&gt; &lt;/property&gt;&lt;/properties&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>测试报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium grid的使用]]></title>
    <url>%2F2017%2F06%2F11%2Fselenium-grid%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[想分布式运行case? 试试下面的操作吧!node机器中运行的代码1java -jar selenium-server-standalone-2.44.0.jar -role node -hub http://&#123;hub服务器地址&#125;:4444/grid/register -port 5500 -maxSession 60 -browser "browserName=chrome,version=node_3,maxInstances=20,platform=WINDOWS" -Dwebdriver.chrome.driver="C:\\chromedriver.exe" 需要jar包selenium-server-standalone-2.44.0.jar， 在windows中一般将如上代码写在一个.bat文件中，每一个node机器中写一个.bat文件，运行的时候直接启动.bat文件 hub机器中运行的代码1java -jar selenium-server-standalone-2.44.0.jar -role hub 属性 解释 -role node 代表的是节点 hub代表的是server -hub 服务器hub地址 http://loaclhost:4444 -port 当前机器启用的端口号， 默认值4444 -timeout 默认值300，设置为0表示没有超时时间，hub永远不会释放node -maxSession 默认值5个， 可以在节点上并行运行的最大浏览器数，比如说现在node支持Firefox 3.6,Firefox 4.0 和Internet Explorer 8，-maxSession=1，你永远不会有超过1个浏览器运行，如果现在maxSession=1，你可以运行两个Firefox 3.6,Firefox 4.0 或者一个Firefox 3.6和一个Internet Explorer 8 -browser &lt;params&gt; browserName={android, chrome, firefox, htmlunit, internet explorer, iphone, opera} version={browser version} firefox_binary={可执行二进制文件路径} chrome_binary={可执行二进制文件路径} maxInstances={此类型的浏览器最大数量} platform={WINDOWS, LINUX, MAC} 注意-maxSession和maxInstances的区别！ 使用json配置node1java -jar selenium-server-standalone.jar -role node -nodeConfig nodeconfig.json 1234567891011121314151617181920212223242526272829303132333435&#123; "capabilities": [ &#123; "browserName": "firefox", "maxInstances": 5, "seleniumProtocol": "WebDriver" &#125;, &#123; "browserName": "chrome", "maxInstances": 5, "seleniumProtocol": "WebDriver" &#125;, &#123; "browserName": "internet explorer", "maxInstances": 1, "seleniumProtocol": "WebDriver" &#125; ], "proxy": "org.openqa.grid.selenium.proxy.DefaultRemoteProxy", "maxSession": 5, "port": 5555, "register": true, "registerCycle": 5000, "hub": "http://localhost:4444", "nodeStatusCheckTimeout": 5000, "nodePolling": 5000, "role": "node", "unregisterIfStillDownAfter": 60000, "downPollingLimit": 2, "debug": false, "servlets" : [], "withoutServlets": [], "custom": &#123;&#125;&#125; 使用json配置hub1java -jar selenium-server-standalone.jar -role hub -hubConfig hubconfig.json 1234567891011121314&#123; "port": 4444, "newSessionWaitTimeout": -1, "servlets" : [], "withoutServlets": [], "custom": &#123;&#125;, "capabilityMatcher": "org.openqa.grid.internal.utils.DefaultCapabilityMatcher", "throwOnCapabilityNotPresent": true, "cleanUpCycle": 5000, "role": "hub", "debug": false, "browserTimeout": 0, "timeout": 1800&#125; 你可以打开http://127.0.0.1:4444/grid/console查看Hub管理页面 如何使用？ 在selenide中 1Configuration.remote = http://127.0.0.1:4444/wd/hub 在selenium中 12DesiredCapabilities chromeDC = DesiredCapabilities.chrome();WebDriver retDriver = new RemoteWebDriver(new URL("http://127.0.0.1:4444/wd/hub"), chromeDC );]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[locust的使用]]></title>
    <url>%2F2017%2F06%2F11%2Flocust%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Locust是什么？Locust 是一个开源负载测试工具。使用 Python 代码定义用户行为，也可以仿真百万个用户。Locust 是非常简单易用，分布式，用户负载测试工具。Locust 主要为网站或者其他系统进行负载测试，能测试出一个系统可以并发处理多少用户。Locust 是完全基于时间的，因此单个机器支持几千个并发用户。相比其他许多事件驱动的应用，Locust 不使用回调，而是使用轻量级的处理方式 gevent。 安装1pip install locustio 如果你打算通过多进程或多机，分布式地运行Locust，我们建议你也安装pyzmq：1pip install pyzmq TaskSet类每个Locust类必须有一个指向一个TaskSet的task_set属性。TaskSet是任务的集合，这些任务是普通的python可调用对象。当负载测试启动的时候，产生的每一个Locust类的实例都会开始执行它们的TaskSet。接下来发生的是，每个TaskSet会选择它的任务中的一个，并且调用它。接下来等待min_wait到max_wait毫秒，然后它会再选择下一个要被调用的任务，再等待，等等。 声明任务为TaskSet声明任务最典型的方式是使用task装饰器。下面是一个例子：123456789101112131415161718192021222324252627def index(l): l.client.get("/")def stats(l): l.client.get("/stats/requests")class UserTasks(TaskSet): # one can specify tasks like this tasks = [index, stats] # but it might be convenient to use the @task decorator @task(3) def task1(self): self.client.get("/does_not_exist") @task(6) def task2(self): passclass WebsiteUser(HttpLocust): """ Locust user class that does requests to the locust web server running on localhost """ host = "http://127.0.0.1:8089" min_wait = 2000 max_wait = 5000 task_set = UserTasks @task装饰器带一个可选的weight参数，它用于指定任务的执行比例。在下面的例子中，task2的执行次数是task1的两倍： TaskSet支持嵌套 123456class MyTaskSet(TaskSet): @task class SubTaskSet(TaskSet): @task def my_task(self): pass on_start函数TaskSet类可以定义一个on_start方法，当模拟用户开始执行TaskSet类的时候，on_start方法会被调用。 HttpLocust类本文已经包含了Locust用户的任务调度部分，为了真正的给一个系统进行负载测试，我们需要生成HTTP请求，HttpLocust类的存在，就是为了解决这个问题。当使用HttpLocust类的时候，每个实例都有一个client属性—它是能够用于生成HTTP请求的HttpSession类的实例123456789101112131415from locust import HttpLocust, TaskSet, taskclass MyTaskSet(TaskSet): @task(2) def index(self): self.client.get("/") @task(1) def about(self): self.client.get("/about/")class MyLocust(HttpLocust): task_set = MyTaskSet min_wait = 5000 max_wait = 15000 使用上面的Locust类，每个模拟用户在请求之间都会等待5-15秒，并且/的请求次数是/about/的两倍。 用心的读者可能会觉得很奇怪：在TaskSet内部我们使用self.client而非self.locust.client开引用HttpSession实例，我们能这么做是因为：TaskSet类有一个便捷的被称作client的属性，它简单的返回self.locust.client。 生成GET请求的例子123response = self.client.get("/about") print "Response status code:", response.status_code print "Response content:", response.content 生成POST请求的例子1response = self.client.post("/login", &#123;"username":"testuser", "password":"secret"&#125;) 人工控制一个请求被视为成功还是失败默认情况下，除非HTTP响应码是ok(2xx)，否则请求就会被标记为失败。大多数情况下，默认的情况就是我们想要的。然而有时:比如说你期望返回404，或者是测试一个即使发生错误，仍然返回200 OK的系统，就存在人工控制locust将请求视为成功还是失败的需求。 通过使用catch_response参数和with语句，可以把一个响应码是okay的请求标记成失败 123with client.get("/", catch_response=True) as response: if response.content != "Success": response.failure("Got wrong response") 正如可以把响应码为OK的请求标记为失败，也可以使用catch_response参数和with语句，将返回http错误代码的请求在统计中报告为成功。123with client.get("/does_not_exist/", catch_response=True) as response: if response.status_code == 404: response.success() 安全模式HTTP客户端被配置成以安全模式运行，任何由于连接错误，超时之类导致失败的请求都不会抛出异常，而是返回一个空的虚拟的Response对象，在Locust的统计中请求会被报告为一个失败。被返回的虚拟的Response对象的content属性被设置为None，status_code属性被设置为0 将到具有动态参数的URL的请求分组对于网站来说，拥有URL中包含某种动态参数的页面是非常普遍的。通常在Locust的统计中，把这些URL分成一组是有意义的。可以通过给HttpSession实例的请求方法传递name参数，来完成这件事。例子： 123# Statistics for these requests will be grouped under: /blog/?id=[id]for i in range(10): client.get("/blog?id=%i" % i, name="/blog?id=[id]") 启动 如果运行的文件名称为locustfile.py 则可以直接运行 1locust --host=http://example.com 如果locust file被放到了其他的地方，我们可以运行 1locust -f 当前文件夹路径/my_file.py --host=http://example.com 如果需要多线程分布式运行locust，启动的时候需要指定master和slave 1locust -f 当前文件夹路径/my_file.py --host=http://example.com --master 然后我们可以启动任意数量的slave进程：(用master机器的ip替换192.168.0.14)1locust -f my_locustfile.py --slave --master-host=192.168.0.14 分布式运行Locust 参数 属性 解释 -f 文件名 --host 运行的接口的host --master 以master的模式运行locust，web接口会运行在这个节点上 --slave 以slave模式运行locust。 --master-host=X.X.X.X 和--slave一起使用，用来设置master节点的ip或主机名（默认是127.0.0.1） --master-port=5557 和--slave一起使用，用来设置master节点的端口号（默认是5557），注意：locust既会使用指定的端口号，又会使用指定的端口号+1，因此如果设置为5557，那么locust既会使用5557，也会使用5558 --master-bind-host=X.X.X.X 和--master一起使用，决定master节点绑定到哪一个网络接口，默认是*（所有可用的网络接口） min_wait和max_wait属性除了task_set属性，也可以声明min_wait和max_wait属性，它们是一个模拟用户在执行任务之间等待的最大和最小时间，单位是毫秒。min_wait和max_wait默认是1000，因此如果没有声明min_wait和max_wait，locust在执行每个任务之间总是会等待1秒。使用下面的locustfile，在任务之间每个用户等待5-15秒：1234567891011from locust import Locust, TaskSet, taskclass MyTaskSet(TaskSet): @task def my_task(self): print "executing my_task"class MyLocust(Locust): task_set = MyTaskSet min_wait = 5000 max_wait = 15000 参考： http://timd.cn/2015/09/17/locust/https://my.oschina.net/u/2306127/blog/482625]]></content>
      <categories>
        <category>性能测试</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>locust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins笔记]]></title>
    <url>%2F2017%2F06%2F11%2Fjenkins%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[启动Jenkins1java -jar jenkins.war --httpPort=8001 遇到的问题 查看jenkins的HTML文件，然后样式，或者引用的字体加载不出来 Refused to load the font ‘http://localhost:8080/job/nec-server-test/extent-report/extentreports/css/fonts/Roboto-Thin.woff‘ because it violates the following Content Security Policy directive: “default-src ‘none’”. Note that ‘font-src’ was not explicitly set, so ‘default-src’ is used as a fallback. 出现这种问题的情况是jenkins默认使用严格的加载模式，不允许外部的一些js操作导致的，需要将一些规则放宽参考：https://wiki.jenkins-ci.org/display/JENKINS/Configuring+Content+Security+Policy 解决办法：在启动jenkins的时候 使用java -Dhudson.model.DirectoryBrowserSupport.CSP= -jar jenkins.war代替java -jar jenkins.war]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常见操作及设置]]></title>
    <url>%2F2017%2F06%2F11%2Fgit%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E5%8F%8A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[push设置无需每次输入密码http连接方式 方法一git config --global credential.helper wincred 方法二http://[username]:[password]@zychen.com.cn/scm/nec/nec-server.git username: 远程代码块的登录账号password：远程代码块的登录密码@后面的内容及为远程代码块 ssh连接方式传送门 基本配置12345678910# 配置用户信息git config --global user.name stash &lt;用户名&gt;git config --global user.email &lt;公司邮箱&gt; # 关闭自动crlf转换，开启crlf检查git config --global core.autocrlf falsegit config --global core.safecrlf true# 给命令设置别名git config --global alias.st status 常用操作 删除远程仓库的分支 1git push origin :远程分支名 修剪远程中已经删除的分支，但在本地还存在的 1git remote prune origin 回退本地commit的历史 1git reset HEAD^^ 将别的分支的commit的历史复制到当前分支 1git cherry pick -提交的commit号]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenide的入门教程]]></title>
    <url>%2F2017%2F06%2F10%2Fselenide%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Quick Start在pom.xml中加入如下依赖123456&lt;dependency&gt; &lt;groupId&gt;com.codeborne&lt;/groupId&gt; &lt;artifactId&gt;selenide&lt;/artifactId&gt; &lt;version&gt;4.4.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 常用配置 selenide默认使用Firefox浏览器，如何切换成chrome浏览器？ 12System.setProperty("webdriver.chrome.driver", driverPath);Configuration.browser="chrome"; selenide如何设置代理？ 123Proxy proxy = new Proxy();proxy.setHttpProxy("127.0.0.1:8080");WebDriverRunner.setProxy(proxy); selenide如何修改报告默认生成路径？ 1Configuration.reportsFolder = "target/reports/test"+Configuration.browser; selenide如何下载非&lt;a&gt;标签的文件？ 12//默认值是FileDownloadMode.HTTPGET，此值只用作用于&lt;a&gt;标签Configuration.fileDownload = FileDownloadMode.PROXY; 如何保持浏览器运行完不关闭？ 12//默认值是falseConfiguration.holdBrowserOpen = true; 如何使用自己实例化的driver？ 1WebDriverRunner.setWebDriver(driver); 此处需要注意，如果使用自己设置的driver，selenide不会自动关闭brower,需要我们手动关闭！ 常见操作 打开一个url： 1open("https://www.baidu.com/"); 鼠标点击： 123//默认使用css selector的方式来查找元素Selenide.$(element).click();Selenide.$(By.xpath(element)).click(); 文本框赋值：Selenide.$(By.xpath(element)).doubleClick(); 鼠标事件：Selenide.$(By.xpath(element)).contextClick(); 鼠标右键事件：Selenide.$(By.xpath(element)).setValue(value); 判断元素是否存在：Selenide.$(By.xpath(element)).exists(); 下载文件的操作：Selenide.$(By.xpath(element)).download(); 默认只能下载&lt;a&gt;标签的元素若想下载其他标签里面的元素则需另外设置 上传文件的操作：Selenide.$(By.xpath(element)).uploadFile(file); uploadFile的参数为File类型 查询元素的文本内容Selenide.$(By.xpath(element)).text(); 等待直到存在某个元素Selenide.$(By.xpath(element)).waitUntil(exist , timeoutSeconds*1000); 等待直到元素在页面可见Selenide.$(By.xpath(element)).waitUntil(visible , timeoutSeconds*1000); 等待直到满足两个条件中的任意一个,就相当于if(a || b){}这种写法，第一个参数是备注Selenide.$(By.xpath(element)).waitUntil(or(&quot;有一个相等&quot;, text(param1), text(param2)) , timeoutSeconds*1000); 等待直到某个元素不存在Selenide.$(By.xpath(element)).waitUntil(hidden, timeoutSeconds*1000); 等待直到匹配到文本内容Selenide.$(By.xpath(element)).waitUntil(matchesText(text),timeoutSeconds*1000) 此处matchesText里面可以匹配正则表达式 不存在某个元素Selenide.$(By.xpath(element)).shouldNot(exist); 移动鼠标到某个元素上Selenide.$(By.xpath(element)).hover() 获取当前页面titleSelenide.title() 获取当前页面urlWebDriverRunner.url() 切换到另一个页面Selenide.switchTo().window(nameOrHandle) 获取当前driverWebDriverRunner.getWebDriver(); 清除浏览器cookieSelenide.clearBrowserCookies(); 刷新当前页面Selenide.refresh(); 出现alert时候出来情况12Selenide.confirm();Selenide.dismiss();]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>selenide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jacoco统计远程服务器代码覆盖率]]></title>
    <url>%2F2017%2F06%2F09%2Fjacoco%E7%BB%9F%E8%AE%A1%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%2F</url>
    <content type="text"><![CDATA[场景需求由于项目的需要，当前我们开发的服务端代码和接口以及集成测试代码不是写在同一个项目下，当测接口时，我们发送一个http request请求到Linux服务端，然后服务端返回一个response，这样的情况如何做代码覆盖率统计？ 前提条件 安装ant，并且设置环境变量 下载jacoco的jar包 点击下载 服务端设置（Linux）现在的springboot应用非常多，其本身自带tomcat，网上很多都是说修改tomcat的Catalina.sh文件来使用javaagent：1JAVA_OPTS="-javaagent:[yourPath/]jacocoagent.jar=includes=com.didispace.*,output=tcpserver,port=8044,address=30.11.227.26 -Xverify:none" 针对springboot应用使用如下方式运行：1java -javaagent:D:/tools/jacoco-0.7.9/lib/jacocoagent.jar=includes=com.didispace.*,output=tcpserver,port=8044,address=30.11.227.26 -jar Chapter1-1.0.0.jar output有4个值，分别是file,tcpserver,tcpclient,mbean，默认是file。使用file的方式只有在停掉应用服务的时候才能产生覆盖率文件，而使用tcpserver的方式可以在不停止应用服务的情况下下载覆盖率文件 客户端设置（Windows）在客户端运行ant dump之前，这时可以对服务端进行接口以及功能测试，这时所有的调服务端接口操作都会记录代码覆盖率。 结合Jenkins生成report在目录D:\test-resourse\下新建一个文件夹trap，trap文件夹下新建一个build.xml文件，文件内容如下：123456789101112131415&lt;?xml version="1.0" ?&gt;&lt;project name="Jacoco" xmlns:jacoco="antlib:org.jacoco.ant" default="jacoco"&gt; //此处的value里面的路径，对应上面下载的jar文件路径 &lt;property name="jacocoantPath" value="D:/tools/jacoco-0.7.9/lib/jacocoant.jar"/&gt; &lt;property name="integrationJacocoexecPath" value="./jacoco-integration.exec"/&gt; &lt;taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml"&gt; &lt;classpath path="$&#123;jacocoantPath&#125;" /&gt; &lt;/taskdef&gt; &lt;target name="dump"&gt;//此处的address地址即为程序/tomcat所在的linux机器地址，host与上文命令行host对应 &lt;jacoco:dump address="30.11.227.26" port="8044" reset="true" destfile="$&#123;integrationJacocoexecPath&#125;" append="false"/&gt; &lt;/target&gt;&lt;/project&gt; 接着在build.xml文件目录下运行ant dump命令就会在当前目录下出现一个.exec后缀名结尾的文件，出现如下图所示的代表运行成功 本地生成report在trap文件夹下新建一个localReport文件夹，localReport文件夹下新建一个build.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" ?&gt;&lt;project name="jacoco" xmlns:jacoco="antlib:org.jacoco.ant" default="jacoco"&gt; &lt;!--Jacoco的安装路径--&gt; &lt;property name="jacocoantPath" value="[yourPath/]jacocoant.jar"/&gt; &lt;!--最终生成.exec文件的路径，Jacoco就是根据这个文件生成最终的报告的--&gt; &lt;property name="jacocoexecPath" value="[yourPath/]jacoco.exec"/&gt; &lt;!--生成覆盖率报告的路径--&gt; &lt;property name="reportfolderPath" value="[storageReportPath]"/&gt; &lt;!--远程Tomcat服务的ip地址--&gt; &lt;property name="server_ip" value="100.44.44.144"/&gt; &lt;!--前面配置的远程Tomcat服务打开的端口，要跟上面配置的一样--&gt; &lt;property name="server_port" value="8044"/&gt; &lt;!--本地源代码路径--&gt; &lt;property name="checkOrderSrcpath" value="[Srcpath]" /&gt; &lt;!--本地.class文件路径--&gt; &lt;property name="checkOrderClasspath" value="[classPath]" /&gt; &lt;!--让ant知道去哪儿找Jacoco--&gt; &lt;taskdef uri="antlib:org.jacoco.ant" resource="org/jacoco/ant/antlib.xml"&gt; &lt;classpath path="$&#123;jacocoantPath&#125;" /&gt; &lt;/taskdef&gt; &lt;!--dump任务: 根据前面配置的ip地址，和端口号， 访问目标Tomcat服务，并生成.exec文件。--&gt; &lt;target name="dump"&gt; &lt;jacoco:dump address="$&#123;server_ip&#125;" reset="false" destfile="$&#123;jacocoexecPath&#125;" port="$&#123;server_port&#125;" append="true"/&gt; &lt;/target&gt; &lt;!--jacoco任务: 根据前面配置的源代码路径和.class文件路径， 根据dump后，生成的.exec文件，生成最终的html覆盖率报告。--&gt; &lt;target name="report"&gt; &lt;delete dir="$&#123;reportfolderPath&#125;" /&gt; &lt;mkdir dir="$&#123;reportfolderPath&#125;" /&gt; &lt;jacoco:report&gt; &lt;executiondata&gt; &lt;file file="$&#123;jacocoexecPath&#125;" /&gt; &lt;/executiondata&gt; &lt;structure name="JaCoCo Report"&gt; &lt;group name="Check Order related"&gt; &lt;classfiles&gt; &lt;fileset dir="$&#123;checkOrderClasspath&#125;" /&gt; &lt;/classfiles&gt; &lt;sourcefiles encoding="gbk"&gt; &lt;fileset dir="$&#123;checkOrderSrcpath&#125;" /&gt; &lt;/sourcefiles&gt; &lt;/group&gt; &lt;/structure&gt; &lt;html destdir="$&#123;reportfolderPath&#125;" encoding="utf-8" /&gt; &lt;/jacoco:report&gt; &lt;/target&gt;&lt;/project&gt; 在刚才新建的build.xml目录下运行如下命令1234//先执行ant dump//再执行ant report 这时会在build.xml配置文件reportfolderPath属性配置的路径下生成几个文件，其中有一个index.html文件，将其打开就是覆盖率报告]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>jacoco</tag>
      </tags>
  </entry>
</search>